/**
 * @wharfkit/resources v1.2.3
 * https://github.com/wharfkit/resources
 *
 * @license
 * Copyright (c) 2021 Greymass Inc. All Rights Reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 *  1. Redistribution of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 
 *  2. Redistribution in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 * 
 *  3. Neither the name of the copyright holder nor the names of its contributors
 *     may be used to endorse or promote products derived from this software without
 *     specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
 * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
 */
import { Struct, UInt64, UInt128, TimePointSec, Asset, Int64, APIClient, FetchProvider } from '@wharfkit/antelope';
import BN from 'bn.js';
import { __decorate } from 'tslib';
import bigDecimal from 'js-big-decimal';

class PowerUpStateResource extends Struct {
    constructor() {
        super(...arguments);
        this.default_block_cpu_limit = UInt64.from(200000);
        this.default_block_net_limit = UInt64.from(1048576000);
    }
    // Get the current number of allocated units (shift from REX -> PowerUp)
    get allocated() {
        return 1 - Number(this.weight_ratio) / Number(this.target_weight_ratio) / 100;
    }
    // Get the current percentage of reserved units
    get reserved() {
        return new BN(String(this.utilization)) / new BN(String(this.weight));
    }
    // Get the symbol definition for the token
    get symbol() {
        return this.min_price.symbol;
    }
    // Common casting for typed values to numbers
    cast() {
        return {
            adjusted_utilization: Number(this.adjusted_utilization),
            decay_secs: Number(this.decay_secs.value),
            exponent: Number(this.exponent),
            utilization: Number(this.utilization),
            utilization_timestamp: Number(this.utilization_timestamp.value),
            weight: new BN(String(this.weight)),
            weight_ratio: Number(this.weight_ratio),
        };
    }
    // Mimic: https://github.com/EOSIO/eosio.contracts/blob/d7bc0a5cc8c0c2edd4dc61b0126517d0cb46fd94/contracts/eosio.system/src/powerup.cpp#L358
    utilization_increase(sample, frac) {
        const { weight } = this;
        const frac128 = UInt128.from(frac);
        const utilization_increase = new BN(weight.value.mul(new BN(frac128.value))) / Math.pow(10, 15);
        return Math.ceil(utilization_increase);
    }
    // Mimic: https://github.com/EOSIO/eosio.contracts/blob/d7bc0a5cc8c0c2edd4dc61b0126517d0cb46fd94/contracts/eosio.system/src/powerup.cpp#L284-L298
    price_function(utilization) {
        const { exponent, weight } = this.cast();
        const max_price = this.max_price.value;
        const min_price = this.min_price.value;
        let price = min_price;
        const new_exponent = exponent - 1.0;
        if (new_exponent <= 0.0) {
            return max_price;
        }
        else {
            const util_weight = new BN(utilization) / weight;
            price += (max_price - min_price) * Math.pow(util_weight, new_exponent);
        }
        return price;
    }
    // Mimic: https://github.com/EOSIO/eosio.contracts/blob/d7bc0a5cc8c0c2edd4dc61b0126517d0cb46fd94/contracts/eosio.system/src/powerup.cpp#L274-L280
    price_integral_delta(start_utilization, end_utilization) {
        const { exponent, weight } = this.cast();
        const max_price = this.max_price.value;
        const min_price = this.min_price.value;
        const coefficient = (max_price - min_price) / exponent;
        const start_u = new BN(start_utilization) / weight;
        const end_u = new BN(end_utilization) / weight;
        const delta = min_price * end_u -
            min_price * start_u +
            coefficient * Math.pow(end_u, exponent) -
            coefficient * Math.pow(start_u, exponent);
        return delta;
    }
    // Mimic: https://github.com/EOSIO/eosio.contracts/blob/d7bc0a5cc8c0c2edd4dc61b0126517d0cb46fd94/contracts/eosio.system/src/powerup.cpp#L262-L315
    fee(utilization_increase, adjusted_utilization) {
        const { utilization, weight } = this.cast();
        let start_utilization = utilization;
        const end_utilization = start_utilization + utilization_increase;
        let fee = 0;
        if (start_utilization < adjusted_utilization) {
            const min = Math.min(utilization_increase, adjusted_utilization - start_utilization);
            fee += Number(new bigDecimal(this.price_function(adjusted_utilization) * min)
                .divide(new bigDecimal(weight.toString()))
                .getValue());
            start_utilization = adjusted_utilization;
        }
        if (start_utilization < end_utilization) {
            fee += this.price_integral_delta(start_utilization, end_utilization);
        }
        return fee;
    }
    // Mimic: https://github.com/EOSIO/eosio.contracts/blob/d7bc0a5cc8c0c2edd4dc61b0126517d0cb46fd94/contracts/eosio.system/src/powerup.cpp#L105-L117
    determine_adjusted_utilization(options) {
        // Casting EOSIO types to usable formats for JS calculations
        const { decay_secs, utilization, utilization_timestamp } = this.cast();
        let { adjusted_utilization } = this.cast();
        // If utilization is less than adjusted, calculate real time value
        if (utilization < adjusted_utilization) {
            // Create now & adjust JS timestamp to match EOSIO timestamp values
            const ts = options && options.timestamp ? options.timestamp : new Date();
            const now = TimePointSec.from(ts).toMilliseconds() / 1000;
            const diff = adjusted_utilization - utilization;
            let delta = diff * Math.exp(-(now - utilization_timestamp) / decay_secs);
            delta = Math.min(Math.max(delta, 0), diff); // Clamp the delta
            adjusted_utilization = utilization + delta;
        }
        return adjusted_utilization;
    }
}
__decorate([
    Struct.field('uint8')
], PowerUpStateResource.prototype, "version", void 0);
__decorate([
    Struct.field('int64')
], PowerUpStateResource.prototype, "weight", void 0);
__decorate([
    Struct.field('int64')
], PowerUpStateResource.prototype, "weight_ratio", void 0);
__decorate([
    Struct.field('int64')
], PowerUpStateResource.prototype, "assumed_stake_weight", void 0);
__decorate([
    Struct.field('int64')
], PowerUpStateResource.prototype, "initial_weight_ratio", void 0);
__decorate([
    Struct.field('int64')
], PowerUpStateResource.prototype, "target_weight_ratio", void 0);
__decorate([
    Struct.field('time_point_sec')
], PowerUpStateResource.prototype, "initial_timestamp", void 0);
__decorate([
    Struct.field('time_point_sec')
], PowerUpStateResource.prototype, "target_timestamp", void 0);
__decorate([
    Struct.field('float64')
], PowerUpStateResource.prototype, "exponent", void 0);
__decorate([
    Struct.field('uint32')
], PowerUpStateResource.prototype, "decay_secs", void 0);
__decorate([
    Struct.field('asset')
], PowerUpStateResource.prototype, "min_price", void 0);
__decorate([
    Struct.field('asset')
], PowerUpStateResource.prototype, "max_price", void 0);
__decorate([
    Struct.field('int64')
], PowerUpStateResource.prototype, "utilization", void 0);
__decorate([
    Struct.field('int64')
], PowerUpStateResource.prototype, "adjusted_utilization", void 0);
__decorate([
    Struct.field('time_point_sec')
], PowerUpStateResource.prototype, "utilization_timestamp", void 0);

let PowerUpStateResourceCPU = class PowerUpStateResourceCPU extends PowerUpStateResource {
    constructor() {
        super(...arguments);
        // Return smallest units per day, μs (microseconds)
        this.per_day = (options) => this.us_per_day(options);
        // Default frac generation by smallest unit type
        this.frac = (usage, us) => this.frac_by_us(usage, us);
        // Frac generation by ms (milliseconds)
        this.frac_by_ms = (usage, ms) => this.frac_by_us(usage, ms * 1000);
        // Price generation by smallest units, μs (microseconds)
        this.price_per = (usage, us = 1000, options) => this.price_per_us(usage, us, options);
        // Price generation by ms (milliseconds)
        this.price_per_ms = (usage, ms = 1, options) => this.price_per_us(usage, ms * 1000, options);
    }
    // Return ms (milliseconds) per day
    ms_per_day(options) {
        return this.us_per_day(options) / 1000;
    }
    // Return μs (microseconds) per day
    us_per_day(options) {
        const limit = options && options.virtual_block_cpu_limit
            ? options.virtual_block_cpu_limit
            : this.default_block_cpu_limit;
        return Number(limit) * 2 * 60 * 60 * 24;
    }
    // Convert weight to μs (microseconds)
    weight_to_us(sample, weight) {
        return Math.ceil((weight * Number(sample)) / BNPrecision);
    }
    // Convert μs (microseconds) to weight
    us_to_weight(sample, us) {
        return Math.floor((us / Number(sample)) * BNPrecision);
    }
    // Frac generation by μs (microseconds)
    frac_by_us(usage, us) {
        const { weight } = this.cast();
        const frac = new BN(this.us_to_weight(usage.cpu, us)) / weight;
        return Math.floor(frac * Math.pow(10, 15));
    }
    // Price generation by μs (microseconds)
    price_per_us(usage, us = 1000, options) {
        // Determine the utilization increase by this action
        const frac = UInt128.from(this.frac(usage, us));
        const utilization_increase = this.utilization_increase(usage.cpu, frac);
        // Determine the adjusted utilization if needed
        const adjusted_utilization = this.determine_adjusted_utilization(options);
        // Derive the fee from the increase and utilization
        const fee = this.fee(utilization_increase, adjusted_utilization);
        // Force the fee up to the next highest value of precision
        const precision = Math.pow(10, this.max_price.symbol.precision);
        const value = Math.ceil(fee * precision) / precision;
        // Return the modified fee
        return value;
    }
};
PowerUpStateResourceCPU = __decorate([
    Struct.type('powerupstateresourcecpu')
], PowerUpStateResourceCPU);

let PowerUpStateResourceNET = class PowerUpStateResourceNET extends PowerUpStateResource {
    constructor() {
        super(...arguments);
        // Return smallest units per day, bytes
        this.per_day = (options) => this.bytes_per_day(options);
        // Default frac generation by smallest unit type
        this.frac = (usage, bytes) => this.frac_by_bytes(usage, bytes);
        // Frac generation by kb
        this.frac_by_kb = (usage, kilobytes) => this.frac_by_bytes(usage, kilobytes * 1000);
        // Price generation by smallest units, bytes
        this.price_per = (usage, bytes = 1000, options) => this.price_per_byte(usage, bytes, options);
        // Price generation by kb
        this.price_per_kb = (usage, kilobytes = 1, options) => this.price_per_byte(usage, kilobytes * 1000, options);
    }
    // Return kb per day
    kb_per_day(options) {
        return this.bytes_per_day(options) / 1000;
    }
    // Return bytes per day
    bytes_per_day(options) {
        const limit = options && options.virtual_block_net_limit
            ? options.virtual_block_net_limit
            : this.default_block_net_limit;
        return Number(limit) * 2 * 60 * 60 * 24;
    }
    // Convert weight to bytes
    weight_to_bytes(sample, weight) {
        return Math.ceil((weight * Number(sample)) / BNPrecision);
    }
    // Convert bytes to weight
    bytes_to_weight(sample, bytes) {
        return Math.floor((bytes / Number(sample)) * BNPrecision);
    }
    // Frac generation by bytes
    frac_by_bytes(usage, bytes) {
        const { weight } = this.cast();
        const frac = new BN(this.bytes_to_weight(usage.net, bytes)) / weight;
        return Math.floor(frac * Math.pow(10, 15));
    }
    // Price generation by bytes
    price_per_byte(usage, bytes = 1000, options) {
        // Determine the utilization increase by this action
        const frac = UInt128.from(this.frac(usage, bytes));
        const utilization_increase = this.utilization_increase(usage.net, frac);
        // Determine the adjusted utilization if needed
        const adjusted_utilization = this.determine_adjusted_utilization(options);
        // Derive the fee from the increase and utilization
        const fee = this.fee(utilization_increase, adjusted_utilization);
        // Force the fee up to the next highest value of precision
        const precision = Math.pow(10, this.max_price.symbol.precision);
        const value = Math.ceil(fee * precision) / precision;
        // Return the modified fee
        return value;
    }
};
PowerUpStateResourceNET = __decorate([
    Struct.type('powerupstateresourcenet')
], PowerUpStateResourceNET);

let PowerUpState = class PowerUpState extends Struct {
};
__decorate([
    Struct.field('uint8')
], PowerUpState.prototype, "version", void 0);
__decorate([
    Struct.field(PowerUpStateResourceNET)
], PowerUpState.prototype, "net", void 0);
__decorate([
    Struct.field(PowerUpStateResourceCPU)
], PowerUpState.prototype, "cpu", void 0);
__decorate([
    Struct.field('uint32')
], PowerUpState.prototype, "powerup_days", void 0);
__decorate([
    Struct.field('asset')
], PowerUpState.prototype, "min_powerup_fee", void 0);
PowerUpState = __decorate([
    Struct.type('powerupstate')
], PowerUpState);
class PowerUpAPI {
    constructor(parent) {
        this.parent = parent;
    }
    async get_state() {
        const response = await this.parent.api.v1.chain.get_table_rows({
            code: 'eosio',
            scope: '',
            table: 'powup.state',
            type: PowerUpState,
        });
        return response.rows[0];
    }
}

let Connector = class Connector extends Struct {
};
__decorate([
    Struct.field('asset')
], Connector.prototype, "balance", void 0);
__decorate([
    Struct.field('float64')
], Connector.prototype, "weight", void 0);
Connector = __decorate([
    Struct.type('connector')
], Connector);
let ExchangeState = class ExchangeState extends Struct {
};
__decorate([
    Struct.field('asset')
], ExchangeState.prototype, "supply", void 0);
__decorate([
    Struct.field(Connector)
], ExchangeState.prototype, "base", void 0);
__decorate([
    Struct.field(Connector)
], ExchangeState.prototype, "quote", void 0);
ExchangeState = __decorate([
    Struct.type('exchange_state')
], ExchangeState);
let RAMState = class RAMState extends ExchangeState {
    price_per(bytes) {
        const base = this.base.balance.units;
        const quote = this.quote.balance.units;
        return Asset.fromUnits(this.get_input(base, quote, Int64.from(bytes)), this.quote.balance.symbol);
    }
    price_per_kb(kilobytes) {
        return this.price_per(kilobytes * 1000);
    }
    // Derived from https://github.com/EOSIO/eosio.contracts/blob/f6578c45c83ec60826e6a1eeb9ee71de85abe976/contracts/eosio.system/src/exchange_state.cpp#L96
    get_input(base, quote, value) {
        // (quote * value) / (base - value), using 'ceil' to round up
        return quote.multiplying(value).dividing(base.subtracting(value), 'ceil');
    }
};
RAMState = __decorate([
    Struct.type('ramstate')
], RAMState);
class RAMAPI {
    constructor(parent) {
        this.parent = parent;
    }
    async get_state() {
        const response = await this.parent.api.v1.chain.get_table_rows({
            code: 'eosio',
            scope: 'eosio',
            table: 'rammarket',
            type: RAMState,
        });
        return response.rows[0];
    }
}

let REXState = class REXState extends Struct {
    get reserved() {
        return Number(this.total_lent.units) / Number(this.total_lendable.units);
    }
    get symbol() {
        return this.total_lent.symbol;
    }
    get precision() {
        return this.total_lent.symbol.precision;
    }
    get value() {
        return ((Number(this.total_lent.units) + Number(this.total_unlent.units)) /
            Number(this.total_rex.units));
    }
    exchange(amount) {
        return Asset.from((amount.value * this.total_lendable.value) / this.total_rex.value, this.symbol);
    }
    price_per(sample, unit = 1000) {
        // Sample token units
        const tokens = Asset.fromUnits(10000, this.symbol);
        // Spending 1 EOS (10000 units) on REX gives this many tokens
        const bancor = Number(tokens.units) / (this.total_rent.value / this.total_unlent.value);
        // The ratio of the number of tokens received vs the sampled values
        const unitPrice = bancor * (Number(sample.cpu) / BNPrecision);
        // The token units spent per unit
        const perunit = Number(tokens.units) / unitPrice;
        // Multiply the per unit cost by the units requested
        const cost = perunit * unit;
        // Converting to an Asset
        return cost / Math.pow(10, this.precision);
    }
};
__decorate([
    Struct.field('uint8')
], REXState.prototype, "version", void 0);
__decorate([
    Struct.field('asset')
], REXState.prototype, "total_lent", void 0);
__decorate([
    Struct.field('asset')
], REXState.prototype, "total_unlent", void 0);
__decorate([
    Struct.field('asset')
], REXState.prototype, "total_rent", void 0);
__decorate([
    Struct.field('asset')
], REXState.prototype, "total_lendable", void 0);
__decorate([
    Struct.field('asset')
], REXState.prototype, "total_rex", void 0);
__decorate([
    Struct.field('asset')
], REXState.prototype, "namebid_proceeds", void 0);
__decorate([
    Struct.field('uint64')
], REXState.prototype, "loan_num", void 0);
REXState = __decorate([
    Struct.type('rexstate')
], REXState);
class REXAPI {
    constructor(parent) {
        this.parent = parent;
    }
    async get_state() {
        const response = await this.parent.api.v1.chain.get_table_rows({
            code: 'eosio',
            scope: 'eosio',
            table: 'rexpool',
            type: REXState,
        });
        return response.rows[0];
    }
}

const BNPrecision = new BN(100 * 1000 * 1000);
class Resources {
    constructor(options) {
        // the account to use when sampling usage
        this.sampleAccount = 'greymassfuel';
        // token precision/symbol
        this.symbol = '4,EOS';
        this.v1 = {
            powerup: new PowerUpAPI(this),
            ram: new RAMAPI(this),
            rex: new REXAPI(this),
        };
        // Allow overriding of the sample account name
        if (options.sampleAccount) {
            this.sampleAccount = options.sampleAccount;
        }
        // Allow overriding of the system token symbol
        if (options.symbol) {
            this.symbol = options.symbol;
        }
        // Allow variations on how to specify the API configuration
        if (options.api) {
            this.api = options.api;
        }
        else if (options.url) {
            this.api = new APIClient({ provider: new FetchProvider(options.url, options) });
        }
        else {
            throw new Error('Missing url or api client');
        }
    }
    async getSampledUsage() {
        const account = await this.api.v1.chain.get_account(this.sampleAccount);
        const us = UInt128.from(account.cpu_limit.max.value.mul(BNPrecision));
        const byte = UInt128.from(account.net_limit.max.value.mul(BNPrecision));
        const cpu_weight = UInt128.from(account.cpu_weight.value);
        const net_weight = UInt128.from(account.net_weight.value);
        return {
            account,
            cpu: divCeil(us.value, cpu_weight.value),
            net: divCeil(byte.value, net_weight.value),
        };
    }
}
Resources.__className = 'Resources';
function divCeil(num, den) {
    let v = num.div(den);
    const zero = new BN(0);
    const one = new BN(1);
    if (num.mod(den).gt(zero) && v.gt(one)) {
        v = v.sub(one);
    }
    return UInt128.from(v);
}

export { BNPrecision, Connector, ExchangeState, PowerUpAPI, PowerUpState, RAMAPI, RAMState, REXAPI, REXState, Resources };
//# sourceMappingURL=wharfkit-resources.m.js.map
