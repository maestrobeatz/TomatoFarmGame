/**
 * @wharfkit/resources v1.2.3
 * https://github.com/wharfkit/resources
 *
 * @license
 * Copyright (c) 2021 Greymass Inc. All Rights Reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 *  1. Redistribution of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 
 *  2. Redistribution in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 * 
 *  3. Neither the name of the copyright holder nor the names of its contributors
 *     may be used to endorse or promote products derived from this software without
 *     specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
 * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
 */
import { TimePointType, UInt64, Struct, UInt8, Int64, TimePointSec, Float64, UInt32, Asset, UInt128, API, APIClient, APIClientOptions } from '@wharfkit/antelope';

interface PowerUpStateOptions {
    timestamp?: TimePointType;
    virtual_block_cpu_limit?: UInt64;
    virtual_block_net_limit?: UInt64;
}

declare abstract class PowerUpStateResource extends Struct {
    version: UInt8;
    weight: Int64;
    weight_ratio: Int64;
    assumed_stake_weight: Int64;
    initial_weight_ratio: Int64;
    target_weight_ratio: Int64;
    initial_timestamp: TimePointSec;
    target_timestamp: TimePointSec;
    exponent: Float64;
    decay_secs: UInt32;
    min_price: Asset;
    max_price: Asset;
    utilization: Int64;
    adjusted_utilization: Int64;
    utilization_timestamp: TimePointSec;
    readonly default_block_cpu_limit: UInt64;
    readonly default_block_net_limit: UInt64;
    abstract per_day(options?: PowerUpStateOptions): number;
    get allocated(): number;
    get reserved(): number;
    get symbol(): Asset.Symbol;
    cast(): {
        adjusted_utilization: number;
        decay_secs: number;
        exponent: number;
        utilization: number;
        utilization_timestamp: number;
        weight: any;
        weight_ratio: number;
    };
    utilization_increase(sample: UInt128, frac: any): number;
    price_function(utilization: number): number;
    price_integral_delta(start_utilization: number, end_utilization: number): number;
    fee(utilization_increase: any, adjusted_utilization: any): number;
    determine_adjusted_utilization(options?: PowerUpStateOptions): number;
}

declare class PowerUpStateResourceCPU extends PowerUpStateResource {
    per_day: (options?: PowerUpStateOptions | undefined) => number;
    ms_per_day(options?: PowerUpStateOptions): number;
    us_per_day(options?: PowerUpStateOptions): number;
    weight_to_us(sample: UInt128, weight: number): number;
    us_to_weight(sample: UInt128, us: number): number;
    frac: (usage: SampleUsage, us: number) => number;
    frac_by_ms: (usage: SampleUsage, ms: number) => number;
    frac_by_us(usage: SampleUsage, us: number): number;
    price_per: (usage: SampleUsage, us?: number, options?: PowerUpStateOptions | undefined) => number;
    price_per_ms: (usage: SampleUsage, ms?: number, options?: PowerUpStateOptions | undefined) => number;
    price_per_us(usage: SampleUsage, us?: number, options?: PowerUpStateOptions): number;
}

declare class PowerUpStateResourceNET extends PowerUpStateResource {
    per_day: (options?: PowerUpStateOptions | undefined) => number;
    kb_per_day(options?: PowerUpStateOptions): number;
    bytes_per_day(options?: PowerUpStateOptions): number;
    weight_to_bytes(sample: UInt128, weight: number): number;
    bytes_to_weight(sample: UInt128, bytes: number): number;
    frac: (usage: SampleUsage, bytes: number) => number;
    frac_by_kb: (usage: SampleUsage, kilobytes: number) => number;
    frac_by_bytes(usage: SampleUsage, bytes: number): number;
    price_per: (usage: SampleUsage, bytes?: number, options?: PowerUpStateOptions | undefined) => number;
    price_per_kb: (usage: SampleUsage, kilobytes?: number, options?: PowerUpStateOptions | undefined) => number;
    price_per_byte(usage: SampleUsage, bytes?: number, options?: PowerUpStateOptions): number;
}

declare class PowerUpState extends Struct {
    version: UInt8;
    net: PowerUpStateResourceNET;
    cpu: PowerUpStateResourceCPU;
    powerup_days: UInt32;
    min_powerup_fee: Asset;
}
declare class PowerUpAPI {
    private parent;
    constructor(parent: Resources);
    get_state(): Promise<PowerUpState>;
}

declare class Connector extends Struct {
    balance: Asset;
    weight: Float64;
}
declare class ExchangeState extends Struct {
    supply: Asset;
    base: Connector;
    quote: Connector;
}
declare class RAMState extends ExchangeState {
    price_per(bytes: number): Asset;
    price_per_kb(kilobytes: number): Asset;
    get_input(base: Int64, quote: Int64, value: Int64): Int64;
}
declare class RAMAPI {
    private parent;
    constructor(parent: Resources);
    get_state(): Promise<RAMState>;
}

declare class REXState extends Struct {
    version: UInt8;
    total_lent: Asset;
    total_unlent: Asset;
    total_rent: Asset;
    total_lendable: Asset;
    total_rex: Asset;
    namebid_proceeds: Asset;
    loan_num: UInt64;
    get reserved(): number;
    get symbol(): Asset.Symbol;
    get precision(): number;
    get value(): number;
    exchange(amount: Asset): Asset;
    price_per(sample: SampleUsage, unit?: number): number;
}
declare class REXAPI {
    private parent;
    constructor(parent: Resources);
    get_state(): Promise<REXState>;
}

interface ResourcesOptions extends APIClientOptions {
    api?: APIClient;
    sampleAccount?: string;
    symbol?: string;
    url?: string;
}
interface SampleUsage {
    account: API.v1.AccountObject;
    cpu: UInt128;
    net: UInt128;
}
declare const BNPrecision: any;
declare class Resources {
    static __className: string;
    readonly api: APIClient;
    sampleAccount: string;
    symbol: string;
    constructor(options: ResourcesOptions);
    v1: {
        powerup: PowerUpAPI;
        ram: RAMAPI;
        rex: REXAPI;
    };
    getSampledUsage(): Promise<SampleUsage>;
}

export { BNPrecision, Connector, ExchangeState, PowerUpAPI, PowerUpState, RAMAPI, RAMState, REXAPI, REXState, Resources, SampleUsage };
