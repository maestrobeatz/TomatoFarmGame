/**
 * @wharfkit/protocol-esr v1.3.1
 * https://github.com/wharfkit/protocol-esr
 *
 * @license
 * Copyright (c) 2023 Greymass Inc. All Rights Reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * 1.  Redistribution of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 
 * 2.  Redistribution in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 * 
 * 3.  Neither the name of the copyright holder nor the names of its contributors
 *     may be used to endorse or promote products derived from this software without
 *     specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
 * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
 */
import { Struct, PrivateKey, ChainId, SigningRequest, UInt64, Checksum512, Serializer, Bytes, Checksum256, Signature } from '@wharfkit/session';
import { receive } from '@greymass/buoy';
import { AES_CBC } from '@greymass/miniaes';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

let SealedMessage = class SealedMessage extends Struct {
};
__decorate([
    Struct.field('public_key')
], SealedMessage.prototype, "from", void 0);
__decorate([
    Struct.field('uint64')
], SealedMessage.prototype, "nonce", void 0);
__decorate([
    Struct.field('bytes')
], SealedMessage.prototype, "ciphertext", void 0);
__decorate([
    Struct.field('uint32')
], SealedMessage.prototype, "checksum", void 0);
SealedMessage = __decorate([
    Struct.type('sealed_message')
], SealedMessage);
let LinkCreate = class LinkCreate extends Struct {
};
__decorate([
    Struct.field('name')
], LinkCreate.prototype, "session_name", void 0);
__decorate([
    Struct.field('public_key')
], LinkCreate.prototype, "request_key", void 0);
__decorate([
    Struct.field('string', { extension: true })
], LinkCreate.prototype, "user_agent", void 0);
LinkCreate = __decorate([
    Struct.type('link_create')
], LinkCreate);
let LinkInfo = class LinkInfo extends Struct {
};
__decorate([
    Struct.field('time_point_sec')
], LinkInfo.prototype, "expiration", void 0);
LinkInfo = __decorate([
    Struct.type('link_info')
], LinkInfo);

let BuoyMessage = class BuoyMessage extends Struct {
};
__decorate([
    Struct.field('public_key')
], BuoyMessage.prototype, "from", void 0);
__decorate([
    Struct.field('uint64')
], BuoyMessage.prototype, "nonce", void 0);
__decorate([
    Struct.field('bytes')
], BuoyMessage.prototype, "ciphertext", void 0);
__decorate([
    Struct.field('uint32')
], BuoyMessage.prototype, "checksum", void 0);
BuoyMessage = __decorate([
    Struct.type('buoy_message')
], BuoyMessage);
let BuoySession = class BuoySession extends Struct {
};
__decorate([
    Struct.field('name')
], BuoySession.prototype, "session_name", void 0);
__decorate([
    Struct.field('public_key')
], BuoySession.prototype, "request_key", void 0);
__decorate([
    Struct.field('string', { extension: true })
], BuoySession.prototype, "user_agent", void 0);
BuoySession = __decorate([
    Struct.type('buoy_session')
], BuoySession);
let BuoyInfo = class BuoyInfo extends Struct {
};
__decorate([
    Struct.field('time_point_sec')
], BuoyInfo.prototype, "expiration", void 0);
BuoyInfo = __decorate([
    Struct.type('buoy_info')
], BuoyInfo);

async function waitForCallback(callbackArgs, buoyWs, t) {
    // Use the buoy-client to create a promise and wait for a response to the identity request
    const callbackResponse = await receive({ ...callbackArgs, WebSocket: buoyWs || WebSocket });
    if (!callbackResponse) {
        // If the promise was rejected, throw an error
        throw new Error(callbackResponse.rejected);
    }
    // If the promise was rejected, throw an error
    if (typeof callbackResponse.rejected === 'string') {
        throw new Error(callbackResponse.rejected);
    }
    // Process the identity request callback payload
    const payload = JSON.parse(callbackResponse);
    if (payload.sa === undefined || payload.sp === undefined || payload.cid === undefined) {
        throw new Error(t('error.cancelled', { default: 'The request was cancelled from Anchor.' }));
    }
    return payload;
}

/**
 * Return PascalCase version of snake_case string.
 * @internal
 */
function snakeToPascal(name) {
    return name
        .split('_')
        .map((v) => (v[0] ? v[0].toUpperCase() : '') + v.slice(1))
        .join('');
}
/**
 * Return camelCase version of snake_case string.
 * @internal
 */
function snakeToCamel(name) {
    const pascal = snakeToPascal(name);
    return (pascal[0] ? pascal[0].toLowerCase() : '') + pascal.slice(1);
}
/**
 * Print a warning message to console.
 * @internal
 **/
function logWarn(...args) {
    // eslint-disable-next-line no-console
    console.warn('[anchor-link]', ...args);
}
/**
 * Generate a UUID.
 *  @internal
 * */
function uuid() {
    let uuid = '', ii;
    const chars = '0123456789abcdef';
    for (ii = 0; ii < 36; ii += 1) {
        switch (ii) {
            case 8:
            case 13:
            case 18:
            case 23:
                uuid += '-';
                break;
            case 14:
                uuid += '4';
                break;
            case 19:
                uuid += chars[(Math.random() * 4) | (0 + 8)];
                break;
            default:
                uuid += chars[(Math.random() * 16) | 0];
        }
    }
    return uuid;
}
/** Generate a return url that Anchor will redirect back to w/o reload. */
function generateReturnUrl() {
    if (isChromeiOS()) {
        // google chrome on iOS will always open new tab so we just ask it to open again as a workaround
        return 'googlechrome://';
    }
    if (isFirefoxiOS()) {
        // same for firefox
        return 'firefox:://';
    }
    if (isAppleHandheld() && isBrave()) {
        // and brave ios
        return 'brave://';
    }
    if (isAppleHandheld()) {
        // return url with unique fragment required for iOS safari to trigger the return url
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let rv = window.location.href.split('#')[0] + '#';
        for (let i = 0; i < 8; i++) {
            rv += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
        }
        return rv;
    }
    if (isAndroid() && isFirefox()) {
        return 'android-intent://org.mozilla.firefox';
    }
    if (isAndroid() && isEdge()) {
        return 'android-intent://com.microsoft.emmx';
    }
    if (isAndroid() && isOpera()) {
        return 'android-intent://com.opera.browser';
    }
    if (isAndroid() && isBrave()) {
        return 'android-intent://com.brave.browser';
    }
    if (isAndroid() && isAndroidWebView()) {
        return 'android-intent://webview';
    }
    if (isAndroid() && isChromeMobile()) {
        return 'android-intent://com.android.chrome';
    }
    return window.location.href;
}
function isAppleHandheld() {
    return /iP(ad|od|hone)/i.test(navigator.userAgent);
}
function isChromeiOS() {
    return /CriOS/.test(navigator.userAgent);
}
function isChromeMobile() {
    return /Chrome\/[.0-9]* Mobile/i.test(navigator.userAgent);
}
function isFirefox() {
    return /Firefox/i.test(navigator.userAgent);
}
function isFirefoxiOS() {
    return /FxiOS/.test(navigator.userAgent);
}
function isOpera() {
    return /OPR/.test(navigator.userAgent) || /Opera/.test(navigator.userAgent);
}
function isEdge() {
    return /Edg/.test(navigator.userAgent);
}
function isBrave() {
    return navigator['brave'] && typeof navigator['brave'].isBrave === 'function';
}
function isAndroid() {
    return /Android/.test(navigator.userAgent);
}
function isAndroidWebView() {
    return /wv/.test(navigator.userAgent) || /Android.*AppleWebKit/.test(navigator.userAgent);
}

/**
 * createIdentityRequest
 *
 * @param context LoginContext
 * @returns
 */
async function createIdentityRequest(context, buoyUrl) {
    // Create a new private key and public key to act as the request key
    const privateKey = PrivateKey.generate('K1');
    const requestKey = privateKey.toPublic();
    // Create a new BuoySession struct to be used as the info field
    const createInfo = BuoySession.from({
        session_name: context.appName,
        request_key: requestKey,
        user_agent: getUserAgent(),
    });
    // Determine based on the options whether this is a multichain request
    const isMultiChain = !(context.chain || context.chains.length === 1);
    // Create the callback
    const callbackChannel = prepareCallbackChannel(buoyUrl);
    // Determine the chain id(s) to use
    const chainId = isMultiChain
        ? null
        : context.chain
            ? ChainId.from(context.chain.id.array)
            : null;
    const chainIds = isMultiChain
        ? context.chains.map((c) => ChainId.from(c.id.array))
        : [];
    // Create the request
    const request = SigningRequest.identity({
        callback: prepareCallback(callbackChannel),
        scope: String(context.appName),
        chainId,
        chainIds,
        info: {
            link: createInfo,
            scope: String(context.appName),
        },
    }, context.esrOptions);
    const sameDeviceRequest = request.clone();
    if (typeof window !== 'undefined') {
        const returnUrl = generateReturnUrl();
        sameDeviceRequest.setInfoKey('same_device', true);
        sameDeviceRequest.setInfoKey('return_path', returnUrl);
    }
    // Return the request and the callback data
    return {
        callback: callbackChannel,
        request,
        sameDeviceRequest,
        requestKey,
        privateKey,
    };
}
/**
 * prepareTransactionRequest
 *
 * @param resolved ResolvedSigningRequest
 * @returns
 */
function setTransactionCallback(request, buoyUrl) {
    const callback = prepareCallbackChannel(buoyUrl);
    request.setCallback(`${callback.service}/${callback.channel}`, true);
    return callback;
}
function getUserAgent() {
    const version = '1.3.1';
    let agent = `@wharfkit/protocol-esr ${version}`;
    if (typeof navigator !== 'undefined') {
        agent += ' ' + navigator.userAgent;
    }
    return agent;
}
function prepareCallback(callbackChannel) {
    const { service, channel } = callbackChannel;
    return {
        url: `${service}/${channel}`,
        background: true,
    };
}
function prepareCallbackChannel(buoyUrl) {
    return {
        service: buoyUrl,
        channel: uuid(),
    };
}
function sealMessage(message, privateKey, publicKey, nonce) {
    const secret = privateKey.sharedSecret(publicKey);
    if (!nonce) {
        nonce = UInt64.random();
    }
    const key = Checksum512.hash(Serializer.encode({ object: nonce }).appending(secret.array));
    const cbc = new AES_CBC(key.array.slice(0, 32), key.array.slice(32, 48));
    const ciphertext = Bytes.from(cbc.encrypt(Bytes.from(message, 'utf8').array));
    const checksumView = new DataView(Checksum256.hash(key.array).array.buffer);
    const checksum = checksumView.getUint32(0, true);
    return SealedMessage.from({
        from: privateKey.toPublic(),
        nonce,
        ciphertext,
        checksum,
    });
}
async function verifyLoginCallbackResponse(callbackResponse, context) {
    if (!callbackResponse.sig || callbackResponse.sig.length === 0) {
        throw new Error('Invalid response, must have at least one signature');
    }
    let chain;
    if (!context.chain && context.chains.length > 1) {
        if (!callbackResponse.cid) {
            throw new Error('Multi chain response payload must specify resolved chain id (cid)');
        }
    }
    else {
        chain = context.chain || context.chains[0];
        if (callbackResponse.cid && String(chain.id) !== callbackResponse.cid) {
            throw new Error('Got response for wrong chain id');
        }
    }
}
function extractSignaturesFromCallback(payload) {
    const signatures = [];
    let index = 0;
    let sig = payload.sig;
    while (sig) {
        signatures.push(String(sig));
        sig = payload[`sig${index}`];
        index++;
    }
    // Deduplicate and make signatures
    return [...new Set(signatures)].map((s) => Signature.from(s));
}
function isCallback(object) {
    return 'tx' in object;
}

export { BuoyInfo, BuoyMessage, BuoySession, LinkCreate, LinkInfo, SealedMessage, createIdentityRequest, extractSignaturesFromCallback, generateReturnUrl, getUserAgent, isAppleHandheld, isCallback, logWarn, prepareCallback, sealMessage, setTransactionCallback, snakeToCamel, snakeToPascal, uuid, verifyLoginCallbackResponse, waitForCallback };
//# sourceMappingURL=protocol-esr.m.js.map
