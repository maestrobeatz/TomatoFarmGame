import { isInstanceOf, UInt128, UInt64, Float64, Checksum256, Checksum160, Name, Serializer, ABI, Blob, PermissionLevel, Action, Transaction } from '@wharfkit/antelope';
import { PlaceholderAuth } from '@wharfkit/signing-request';
import { ABICache } from '@wharfkit/abicache';

function pascalCase(value) {
    return value
        .split(/_| /)
        .map((w) => {
        return w[0].toUpperCase() + w.slice(1).toLowerCase();
    })
        .join('');
}
function capitalize(string) {
    if (typeof string !== 'string' || string.length === 0) {
        return '';
    }
    return string.charAt(0).toUpperCase() + string.slice(1);
}
function singularize(word) {
    if (word.endsWith('ies')) {
        return word.slice(0, -3) + 'y';
    }
    else if (word.endsWith('ches') || word.endsWith('ses')) {
        return word.slice(0, -2);
    }
    else if (word.endsWith('s') && word.length > 1 && word[word.length - 2] !== 's') {
        return word.slice(0, -1);
    }
    else {
        return word;
    }
}
function indexPositionInWords(index) {
    return [
        'primary',
        'secondary',
        'tertiary',
        'fourth',
        'fifth',
        'sixth',
        'seventh',
        'eighth',
        'ninth',
        'tenth',
    ][index];
}
function wrapIndexValue(value) {
    if (!value) {
        return;
    }
    if (isInstanceOf(value, UInt128) ||
        isInstanceOf(value, UInt64) ||
        isInstanceOf(value, Float64) ||
        isInstanceOf(value, Checksum256) ||
        isInstanceOf(value, Checksum160)) {
        return value;
    }
    if (typeof value === 'number') {
        return UInt64.from(value);
    }
    return Name.from(value);
}
function abiToBlob(abi) {
    const serializedABI = Serializer.encode({ object: abi, type: ABI });
    return new Blob(serializedABI.array);
}
function blobStringToAbi(blobString) {
    const blob = Blob.from(blobString);
    return ABI.from(blob);
}

const defaultParams = {
    json: false,
    limit: 1000,
};
class TableCursor {
    constructor(args) {
        this.endReached = false;
        this.rowsCount = 0;
        this.maxRows = Number.MAX_SAFE_INTEGER;
        this.abi = ABI.from(args.abi);
        this.client = args.client;
        this.params = {
            ...defaultParams,
            ...args.params,
        };
        if (args.maxRows) {
            this.maxRows = args.maxRows;
        }
        const table = this.abi.tables.find((t) => Name.from(t.name).equals(this.params.table));
        if (!table) {
            throw new Error('Table not found');
        }
        this.type = table.type;
    }
    async *[Symbol.asyncIterator]() {
        while (true) {
            const rows = await this.next();
            for (const row of rows) {
                yield row;
            }
            if (rows.length === 0 || !this.next_key) {
                return;
            }
        }
    }
    async reset() {
        this.next_key = undefined;
        this.endReached = false;
        this.rowsCount = 0;
    }
    async all() {
        const rows = [];
        for await (const row of this) {
            rows.push(row);
        }
        return rows;
    }
}

class TableRowCursor extends TableCursor {
    async next(rowsPerAPIRequest = Number.MAX_SAFE_INTEGER) {
        if (this.endReached) {
            return [];
        }
        let lower_bound = this.params.lower_bound;
        if (this.next_key) {
            lower_bound = this.next_key;
        }
        const rowsRemaining = this.maxRows - this.rowsCount;
        const limit = Math.min(rowsRemaining, rowsPerAPIRequest, this.params.limit);
        const query = {
            ...this.params,
            limit,
            lower_bound: wrapIndexValue(lower_bound),
            upper_bound: wrapIndexValue(this.params.upper_bound),
        };
        const result = await this.client.v1.chain.get_table_rows(query);
        const requiresDecoding = this.params.json === false && !query.type;
        const rows = requiresDecoding
            ? result.rows.map((data) => Serializer.decode({
                data,
                abi: this.abi,
                type: this.type,
            }))
            : result.rows;
        this.next_key = result.next_key;
        this.rowsCount += rows.length;
        if (!result.next_key || rows.length === 0 || this.rowsCount === this.maxRows) {
            this.endReached = true;
        }
        return rows;
    }
}

class TableScopeCursor extends TableCursor {
    async next(rowsPerAPIRequest = Number.MAX_SAFE_INTEGER) {
        if (this.endReached) {
            return [];
        }
        let lower_bound = this.params.lower_bound;
        if (this.next_key) {
            lower_bound = this.next_key;
        }
        const rowsRemaining = this.maxRows - this.rowsCount;
        const limit = Math.min(rowsRemaining, rowsPerAPIRequest, this.params.limit);
        const query = {
            code: this.params.code,
            table: this.params.table,
            limit,
            lower_bound: lower_bound ? String(lower_bound) : undefined,
            upper_bound: this.params.upper_bound ? String(this.params.upper_bound) : undefined,
        };
        const result = await this.client.v1.chain.get_table_by_scope(query);
        const rows = result.rows;
        this.next_key = result.more;
        this.rowsCount += rows.length;
        if (!result.more || rows.length === 0 || this.rowsCount === this.maxRows) {
            this.endReached = true;
        }
        return rows;
    }
}

class Table {
    constructor(args) {
        this.defaultRowLimit = 1000;
        this.abi = ABI.from(args.abi);
        this.account = Name.from(args.account);
        this.name = Name.from(args.name);
        this.client = args.client;
        this.rowType = args.rowType;
        this.fieldToIndex = args.fieldToIndex;
        const tableABI = this.abi.tables.find((table) => this.name.equals(table.name));
        if (!tableABI) {
            throw new Error(`Table ${this.name} not found in ABI`);
        }
        this.tableABI = tableABI;
        this.defaultScope = args.defaultScope;
    }
    static from(tableParams) {
        return new Table(tableParams);
    }
    query(params = {}) {
        const tableRowsParams = {
            table: this.name,
            code: this.account,
            scope: params.scope !== undefined
                ? String(params.scope)
                : this.defaultScope || this.account,
            type: this.rowType,
            index_position: params.index_position,
            key_type: params.key_type,
            lower_bound: wrapIndexValue(params.from),
            upper_bound: wrapIndexValue(params.to),
            limit: params.rowsPerAPIRequest || this.defaultRowLimit,
            reverse: params.reverse,
        };
        if (params.index) {
            const fieldToIndexMapping = this.getFieldToIndex();
            if (!fieldToIndexMapping[params.index]) {
                throw new Error(`Field ${params.index} is not listed in the ABI under key_names/key_types. Try using 'index_position' instead.`);
            }
            tableRowsParams.index_position = fieldToIndexMapping[params.index].index_position;
        }
        return new TableRowCursor({
            abi: this.abi,
            client: this.client,
            maxRows: params.maxRows,
            params: tableRowsParams,
        });
    }
    async get(value, params = {}) {
        const tableRowsParams = {
            table: this.name,
            code: this.account,
            scope: params.scope !== undefined
                ? String(params.scope)
                : this.defaultScope || this.account,
            type: this.rowType,
            limit: 1,
            lower_bound: wrapIndexValue(value),
            upper_bound: wrapIndexValue(value),
            index_position: params.index_position,
            key_type: params.key_type,
            json: false,
            reverse: params.reverse,
        };
        if (params.index) {
            const fieldToIndexMapping = this.getFieldToIndex();
            if (!fieldToIndexMapping[params.index]) {
                throw new Error(`Field ${params.index} is not listed in the ABI under key_names/key_types. Try using 'index_position' instead.`);
            }
            tableRowsParams.index_position = fieldToIndexMapping[params.index].index_position;
        }
        const { rows } = await this.client.v1.chain.get_table_rows(tableRowsParams);
        if (rows.length === 0) {
            return undefined;
        }
        let [row] = rows;
        if (!this.rowType) {
            row = Serializer.decode({
                data: row,
                abi: this.abi,
                type: this.tableABI.type,
            });
        }
        if (params.json) {
            row = Serializer.objectify(row);
        }
        return row;
    }
    first(maxRows, params = {}) {
        return this.query({
            ...params,
            maxRows,
        });
    }
    async all(params = {}) {
        return this.query(params).all();
    }
    getFieldToIndex() {
        if (this.fieldToIndex) {
            return this.fieldToIndex;
        }
        const fieldToIndex = {};
        for (let i = 0; i < this.tableABI.key_names.length; i++) {
            fieldToIndex[this.tableABI.key_names[i]] = {
                type: this.tableABI.key_types[i],
                index_position: indexPositionInWords(i),
            };
        }
        return fieldToIndex;
    }
    scopes(params = {}) {
        const tableRowsParams = {
            code: this.account,
            table: this.name,
            lower_bound: wrapIndexValue(params.from),
            upper_bound: wrapIndexValue(params.to),
            limit: params.rowsPerAPIRequest || this.defaultRowLimit,
            reverse: params.reverse,
        };
        return new TableScopeCursor({
            abi: this.abi,
            client: this.client,
            maxRows: params.maxRows,
            params: tableRowsParams,
        });
    }
}

class Contract {
    constructor(args) {
        if (!args.abi) {
            throw new Error('Contract requires an ABI');
        }
        this.abi = ABI.from(args.abi);
        if (!args.account) {
            throw new Error('Contract requires an account name');
        }
        this.account = Name.from(args.account);
        if (!args.client) {
            throw new Error('Contract requires an APIClient');
        }
        this.client = args.client;
    }
    get tableNames() {
        return this.abi.tables.map((table) => String(table.name));
    }
    hasTable(name) {
        return this.tableNames.includes(String(name));
    }
    table(name, scope, rowType) {
        if (!this.hasTable(name)) {
            throw new Error(`Contract (${this.account}) does not have a table named (${name})`);
        }
        return Table.from({
            abi: this.abi,
            account: this.account,
            client: this.client,
            defaultScope: scope,
            name,
            rowType,
        });
    }
    get actionNames() {
        return this.abi.actions.map((action) => String(action.name));
    }
    hasAction(name) {
        return this.actionNames.includes(String(name));
    }
    action(name, data, options) {
        if (!this.hasAction(name)) {
            throw new Error(`Contract (${this.account}) does not have an action named (${name})`);
        }
        let authorization = [PlaceholderAuth];
        if (options && options.authorization) {
            authorization = options.authorization.map((auth) => PermissionLevel.from(auth));
        }
        return Action.from({
            account: this.account,
            name,
            authorization,
            data,
        }, this.abi);
    }
    async readonly(name, data) {
        if (!data) {
            data = {};
        }
        const action = this.action(name, data);
        action.authorization = [];
        const transaction = Transaction.from({
            ref_block_num: 0,
            ref_block_prefix: 0,
            expiration: 0,
            actions: [action],
        });
        const response = await this.client.v1.chain.send_read_only_transaction(transaction);
        const hexData = response.processed.action_traces[0].return_value_hex_data;
        const returnType = this.abi.action_results.find((a) => Name.from(a.name).equals(name));
        if (!returnType) {
            throw new Error(`Return type for ${name} not defined in the ABI.`);
        }
        return Serializer.decode({
            data: hexData,
            type: returnType.result_type,
            abi: this.abi,
        });
    }
    actions(actions, options) {
        return actions.map((action) => this.action(action.name, action.data, {
            authorization: action.authorization || options?.authorization,
        }));
    }
    ricardian(name) {
        if (!this.hasAction(name)) {
            throw new Error(`Contract (${this.account}) does not have an action named (${name})`);
        }
        const action = this.abi.actions.find((action) => Name.from(action.name).equals(name));
        if (!action || !action.ricardian_contract) {
            throw new Error(`Contract (${this.account}) action named (${name}) does not have a defined ricardian contract`);
        }
        return action.ricardian_contract;
    }
}

const defaultContractKitOptions = {};
class ContractKit {
    constructor(args, options = defaultContractKitOptions) {
        if (args.client) {
            this.client = args.client;
        }
        else {
            throw new Error('A `client` must be passed when initializing the ContractKit.');
        }
        if (options.abiCache) {
            this.abiCache = options.abiCache;
        }
        else {
            this.abiCache = new ABICache(this.client);
        }
        if (options.abis) {
            options.abis.forEach(({ name, abi }) => this.abiCache.setAbi(Name.from(name), ABI.from(abi)));
        }
    }
    async load(contract) {
        const account = Name.from(contract);
        const abiDef = await this.abiCache.getAbi(account);
        return new Contract({
            abi: ABI.from(abiDef),
            account,
            client: this.client,
        });
    }
}

export { Contract, ContractKit, Table, TableRowCursor, TableScopeCursor, abiToBlob, blobStringToAbi, capitalize, ContractKit as default, indexPositionInWords, pascalCase, singularize, wrapIndexValue };
//# sourceMappingURL=contract.m.js.map
