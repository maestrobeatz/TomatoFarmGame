import { ABI, APIClient, API, ABIDef, NameType, Name, PermissionLevelType, BytesType, ABISerializableObject, Action, Blob } from '@wharfkit/antelope';
import { ABICacheInterface } from '@wharfkit/abicache';

/** Mashup of valid types for an APIClient call to v1.chain.get_table_rows */
type TableRowParamsTypes = API.v1.GetTableRowsParams | API.v1.GetTableRowsParamsKeyed | API.v1.GetTableRowsParamsTyped;
interface TableCursorArgs {
    /** The ABI for the contract this table belongs to */
    abi: ABIDef;
    /** The APIClient instance to use for API requests */
    client: APIClient;
    /** The parameters used for the v1/chain/get_table_rows call */
    params: TableRowParamsTypes;
    /** The maximum number of rows the cursor should retrieve */
    maxRows?: number;
}
declare abstract class TableCursor<RowType = any> {
    /** The ABI for the contract this table belongs to */
    readonly abi: ABI;
    /** The type of the table, as defined in the ABI */
    readonly type: string;
    /** The parameters used for the v1/chain/get_table_rows call */
    readonly params: TableRowParamsTypes;
    /** The APIClient instance to use for API requests */
    readonly client: APIClient;
    /** For iterating on the cursor, the next key to query against lower_bounds */
    protected next_key: API.v1.TableIndexType | string | undefined;
    /** Whether or not the cursor believes it has reached the end of its results */
    protected endReached: boolean;
    /** The number of rows the cursor has retrieved */
    protected rowsCount: number;
    /** The maximum number of rows the cursor should retrieve */
    protected maxRows: number;
    /**
     * Create a new TableCursor instance.
     *
     * @param args.abi The ABI for the contract.
     * @param args.client The APIClient instance to use for API requests.
     * @param args.params The parameters to use for the table query.
     * @param args.maxRows The maximum number of rows to fetch.
     * @returns A new TableCursor instance.
     */
    constructor(args: TableCursorArgs);
    /**
     * Implements the async iterator protocol for the cursor.
     *
     * @returns An iterator for all rows in the table.
     */
    [Symbol.asyncIterator](): AsyncGenerator<Awaited<RowType>, void, unknown>;
    /**
     * Fetch the next batch of rows from the cursor.
     *
     * @param rowsPerAPIRequest The number of rows to fetch per API request.
     * @returns A promise containing the next batch of rows.
     */
    abstract next(rowsPerAPIRequest?: number): Promise<RowType[]>;
    /**
     * Reset the internal state of the cursor
     */
    reset(): Promise<void>;
    /**
     * Fetch all rows from the cursor by recursively calling next() until the end is reached.
     *
     * @returns A promise containing all rows for the cursor.
     */
    all(): Promise<RowType[]>;
}

declare class TableScopeCursor extends TableCursor {
    /**
     * Fetch the next batch of rows from the cursor.
     *
     * @param rowsPerAPIRequest The number of rows to fetch per API request.
     * @returns A promise containing the next batch of rows.
     */
    next(rowsPerAPIRequest?: number): Promise<API.v1.GetTableByScopeResponseRow[]>;
}

interface QueryParams {
    index?: string;
    index_position?: string;
    scope?: NameType | number;
    key_type?: keyof API.v1.TableIndexTypes;
    json?: boolean;
    from?: API.v1.TableIndexType | string | number;
    to?: API.v1.TableIndexType | string | number;
    maxRows?: number;
    rowsPerAPIRequest?: number;
    reverse?: boolean;
}
interface FieldToIndex {
    [key: string]: {
        type: string;
        index_position: string;
    };
}
interface TableParams<TableRow = any> {
    abi: ABIDef;
    account: NameType;
    client: APIClient;
    name: NameType;
    rowType?: TableRow;
    fieldToIndex?: FieldToIndex;
    defaultRowLimit?: number;
    defaultScope?: NameType;
}
interface GetTableRowsOptions {
    limit?: number;
    scope?: NameType;
}
/**
 * Represents a table in a smart contract.
 * Provides methods for querying rows in the table.
 *
 * @typeparam TableRow The type of rows in the table.
 */
declare class Table<RowType = any> {
    readonly abi: ABI;
    readonly account: Name;
    readonly client: APIClient;
    readonly name: Name;
    readonly rowType?: RowType;
    readonly tableABI: ABI.Table;
    private fieldToIndex?;
    defaultScope?: NameType;
    defaultRowLimit: number;
    /**
     * Constructs a new `Table` instance.
     *
     * @param {TableParams} tableParams - Parameters for the table.
     * The parameters should include:
     *  - `contract`: Name of the contract that this table is associated with.
     *  - `name`: Name of the table.
     *  - `client`: Client object to interact with the network.
     *  - `rowType`: (optional) Custom row type.
     *  - `fieldToIndex`: (optional) Mapping of fields to their indices.
     */
    constructor(args: TableParams);
    /**
     * Creates a new `Table` instance from the given parameters.
     *
     * @param {TableParams} tableParams - Parameters for the table.
     * The parameters should include:
     *  - `contract`: Name of the contract that this table is associated with.
     *  - `name`: Name of the table.
     *  - `client`: Client object to interact with the network.
     *  - `rowType`: (optional) Custom row type.
     *  - `fieldToIndex`: (optional) Mapping of fields to their indices.
     * @returns {Table} A new Table instance.
     */
    static from<RowType = any>(tableParams: TableParams): Table<RowType>;
    /**
     * Retrieves the rows from the table that match the given parameters.
     *
     * @param {QueryParams} queryParams - Query parameters to filter rows (eg. `{id: {from: 1, to: 10}}`)
     *  Each key-value pair in the queryParams object corresponds to a field and its expected value in the table.
     * @returns {TableCursor<TableRow>} Promise resolving to a `TableCursor` of the filtered table rows.
     */
    query(params?: QueryParams): TableCursor<RowType>;
    /**
     * Retrieves the row from the table that matches the given parameters.
     *
     * @param {API.v1.TableIndexType | string} value - The value to match against the index.
     * @param {QueryParams} queryParams - Query parameters to identify a single row (eg. `{ id: 1 }`).
     *  Each key-value pair in the queryParams object corresponds to a field and its expected value in the table.
     * @returns {Promise<TableRow>} Promise resolving to a single table row.
     */
    get(value?: API.v1.TableIndexType | string, params?: QueryParams): Promise<RowType | undefined>;
    /**
     * Retrieves all the rows from the table.
     *
     * @param {number} maxRows - The maximum number of rows to return.
     * @param {QueryParams} queryParams - Query parameters to filter rows.
     * @returns {TableCursor<TableRow>} Promise resolving to a `TableCursor` of the table rows.
     */
    first(maxRows: number, params?: QueryParams): TableCursor<RowType>;
    /**
     * Returns all the rows from the table.
     * @returns {Promise<TableRow[]>} Promise resolving to an array of table rows.
     */
    all(params?: QueryParams): Promise<RowType[]>;
    getFieldToIndex(): any;
    scopes(params?: QueryParams): TableScopeCursor;
}

interface ContractArgs {
    abi: ABIDef;
    account: NameType;
    client: APIClient;
}
interface ActionOptions {
    authorization?: PermissionLevelType[];
}
type ActionDataType = BytesType | ABISerializableObject | Record<string, any>;
type ActionConstructor = (data: ActionDataType, options?: ActionOptions) => Action;
interface ActionsArgs {
    name: NameType;
    data: ActionDataType;
    authorization?: PermissionLevelType[];
}
/**
 * Represents a smart contract deployed to a specific blockchain.
 * Provides methods for interacting with the contract such as
 * calling actions, reading tables, and getting the ABI of the contract.
 */
declare class Contract {
    readonly abi: ABI;
    readonly account: Name;
    readonly client: APIClient;
    /**
     * Constructs a new `Contract` instance.
     *
     * @param {ContractArgs} args - The required arguments for a contract.
     */
    constructor(args: ContractArgs);
    get tableNames(): string[];
    hasTable(name: NameType): boolean;
    table<RowType>(name: NameType, scope?: NameType, rowType?: any): Table<RowType | any>;
    get actionNames(): string[];
    hasAction(name: NameType): boolean;
    action(name: any, data: ActionDataType, options?: ActionOptions): Action;
    readonly(name: any, data?: ActionDataType): Promise<any>;
    actions(actions: ActionsArgs[], options?: ActionOptions): Action[];
    ricardian(name: NameType): string;
}

declare class TableRowCursor<RowType = any> extends TableCursor {
    /**
     * Fetch the next batch of rows from the cursor.
     *
     * @param rowsPerAPIRequest The number of rows to fetch per API request.
     * @returns A promise containing the next batch of rows.
     */
    next(rowsPerAPIRequest?: number): Promise<RowType[]>;
}

interface ContractKitArgs {
    client: APIClient;
}
interface ABIDefinition {
    name: NameType;
    abi: ABIDef;
}
interface ContractKitOptions {
    abiCache?: ABICacheInterface;
    abis?: ABIDefinition[];
}
declare class ContractKit {
    readonly abiCache: ABICacheInterface;
    readonly client: APIClient;
    constructor(args: ContractKitArgs, options?: ContractKitOptions);
    /**
     * Load a contract by name from an API endpoint
     *
     * @param contract The name of the contract to load
     * @returns
     */
    load(contract: NameType): Promise<Contract>;
}

type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
declare function pascalCase(value: string): string;
declare function capitalize(string: any): string;
declare function singularize(word: string): string;
declare function indexPositionInWords(index: number): string;
declare function wrapIndexValue(value: any): API.v1.TableIndexType | undefined;
declare function abiToBlob(abi: ABI): Blob;
declare function blobStringToAbi(blobString: string): ABI;

export { ABIDefinition, ActionConstructor, ActionDataType, ActionOptions, ActionsArgs, Contract, ContractArgs, ContractKit, ContractKitArgs, ContractKitOptions, GetTableRowsOptions, PartialBy, QueryParams, Table, TableRowCursor, TableScopeCursor, abiToBlob, blobStringToAbi, capitalize, ContractKit as default, indexPositionInWords, pascalCase, singularize, wrapIndexValue };
