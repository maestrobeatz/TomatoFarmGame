'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var antelope = require('@wharfkit/antelope');
var signingRequest = require('@wharfkit/signing-request');
var abicache = require('@wharfkit/abicache');

function pascalCase(value) {
    return value
        .split(/_| /)
        .map((w) => {
        return w[0].toUpperCase() + w.slice(1).toLowerCase();
    })
        .join('');
}
function capitalize(string) {
    if (typeof string !== 'string' || string.length === 0) {
        return '';
    }
    return string.charAt(0).toUpperCase() + string.slice(1);
}
function singularize(word) {
    if (word.endsWith('ies')) {
        return word.slice(0, -3) + 'y';
    }
    else if (word.endsWith('ches') || word.endsWith('ses')) {
        return word.slice(0, -2);
    }
    else if (word.endsWith('s') && word.length > 1 && word[word.length - 2] !== 's') {
        return word.slice(0, -1);
    }
    else {
        return word;
    }
}
function indexPositionInWords(index) {
    return [
        'primary',
        'secondary',
        'tertiary',
        'fourth',
        'fifth',
        'sixth',
        'seventh',
        'eighth',
        'ninth',
        'tenth',
    ][index];
}
function wrapIndexValue(value) {
    if (!value) {
        return;
    }
    if (antelope.isInstanceOf(value, antelope.UInt128) ||
        antelope.isInstanceOf(value, antelope.UInt64) ||
        antelope.isInstanceOf(value, antelope.Float64) ||
        antelope.isInstanceOf(value, antelope.Checksum256) ||
        antelope.isInstanceOf(value, antelope.Checksum160)) {
        return value;
    }
    if (typeof value === 'number') {
        return antelope.UInt64.from(value);
    }
    return antelope.Name.from(value);
}
function abiToBlob(abi) {
    const serializedABI = antelope.Serializer.encode({ object: abi, type: antelope.ABI });
    return new antelope.Blob(serializedABI.array);
}
function blobStringToAbi(blobString) {
    const blob = antelope.Blob.from(blobString);
    return antelope.ABI.from(blob);
}

const defaultParams = {
    json: false,
    limit: 1000,
};
class TableCursor {
    constructor(args) {
        this.endReached = false;
        this.rowsCount = 0;
        this.maxRows = Number.MAX_SAFE_INTEGER;
        this.abi = antelope.ABI.from(args.abi);
        this.client = args.client;
        this.params = Object.assign(Object.assign({}, defaultParams), args.params);
        if (args.maxRows) {
            this.maxRows = args.maxRows;
        }
        const table = this.abi.tables.find((t) => antelope.Name.from(t.name).equals(this.params.table));
        if (!table) {
            throw new Error('Table not found');
        }
        this.type = table.type;
    }
    [Symbol.asyncIterator]() {
        return tslib.__asyncGenerator(this, arguments, function* _a() {
            while (true) {
                const rows = yield tslib.__await(this.next());
                for (const row of rows) {
                    yield yield tslib.__await(row);
                }
                if (rows.length === 0 || !this.next_key) {
                    return yield tslib.__await(void 0);
                }
            }
        });
    }
    reset() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this.next_key = undefined;
            this.endReached = false;
            this.rowsCount = 0;
        });
    }
    all() {
        var _a, e_1, _b, _c;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const rows = [];
            try {
                for (var _d = true, _e = tslib.__asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const row = _c;
                        rows.push(row);
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return rows;
        });
    }
}

class TableRowCursor extends TableCursor {
    next(rowsPerAPIRequest = Number.MAX_SAFE_INTEGER) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.endReached) {
                return [];
            }
            let lower_bound = this.params.lower_bound;
            if (this.next_key) {
                lower_bound = this.next_key;
            }
            const rowsRemaining = this.maxRows - this.rowsCount;
            const limit = Math.min(rowsRemaining, rowsPerAPIRequest, this.params.limit);
            const query = Object.assign(Object.assign({}, this.params), { limit, lower_bound: wrapIndexValue(lower_bound), upper_bound: wrapIndexValue(this.params.upper_bound) });
            const result = yield this.client.v1.chain.get_table_rows(query);
            const requiresDecoding = this.params.json === false && !query.type;
            const rows = requiresDecoding
                ? result.rows.map((data) => antelope.Serializer.decode({
                    data,
                    abi: this.abi,
                    type: this.type,
                }))
                : result.rows;
            this.next_key = result.next_key;
            this.rowsCount += rows.length;
            if (!result.next_key || rows.length === 0 || this.rowsCount === this.maxRows) {
                this.endReached = true;
            }
            return rows;
        });
    }
}

class TableScopeCursor extends TableCursor {
    next(rowsPerAPIRequest = Number.MAX_SAFE_INTEGER) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.endReached) {
                return [];
            }
            let lower_bound = this.params.lower_bound;
            if (this.next_key) {
                lower_bound = this.next_key;
            }
            const rowsRemaining = this.maxRows - this.rowsCount;
            const limit = Math.min(rowsRemaining, rowsPerAPIRequest, this.params.limit);
            const query = {
                code: this.params.code,
                table: this.params.table,
                limit,
                lower_bound: lower_bound ? String(lower_bound) : undefined,
                upper_bound: this.params.upper_bound ? String(this.params.upper_bound) : undefined,
            };
            const result = yield this.client.v1.chain.get_table_by_scope(query);
            const rows = result.rows;
            this.next_key = result.more;
            this.rowsCount += rows.length;
            if (!result.more || rows.length === 0 || this.rowsCount === this.maxRows) {
                this.endReached = true;
            }
            return rows;
        });
    }
}

class Table {
    constructor(args) {
        this.defaultRowLimit = 1000;
        this.abi = antelope.ABI.from(args.abi);
        this.account = antelope.Name.from(args.account);
        this.name = antelope.Name.from(args.name);
        this.client = args.client;
        this.rowType = args.rowType;
        this.fieldToIndex = args.fieldToIndex;
        const tableABI = this.abi.tables.find((table) => this.name.equals(table.name));
        if (!tableABI) {
            throw new Error(`Table ${this.name} not found in ABI`);
        }
        this.tableABI = tableABI;
        this.defaultScope = args.defaultScope;
    }
    static from(tableParams) {
        return new Table(tableParams);
    }
    query(params = {}) {
        const tableRowsParams = {
            table: this.name,
            code: this.account,
            scope: params.scope !== undefined
                ? String(params.scope)
                : this.defaultScope || this.account,
            type: this.rowType,
            index_position: params.index_position,
            key_type: params.key_type,
            lower_bound: wrapIndexValue(params.from),
            upper_bound: wrapIndexValue(params.to),
            limit: params.rowsPerAPIRequest || this.defaultRowLimit,
            reverse: params.reverse,
        };
        if (params.index) {
            const fieldToIndexMapping = this.getFieldToIndex();
            if (!fieldToIndexMapping[params.index]) {
                throw new Error(`Field ${params.index} is not listed in the ABI under key_names/key_types. Try using 'index_position' instead.`);
            }
            tableRowsParams.index_position = fieldToIndexMapping[params.index].index_position;
        }
        return new TableRowCursor({
            abi: this.abi,
            client: this.client,
            maxRows: params.maxRows,
            params: tableRowsParams,
        });
    }
    get(value, params = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const tableRowsParams = {
                table: this.name,
                code: this.account,
                scope: params.scope !== undefined
                    ? String(params.scope)
                    : this.defaultScope || this.account,
                type: this.rowType,
                limit: 1,
                lower_bound: wrapIndexValue(value),
                upper_bound: wrapIndexValue(value),
                index_position: params.index_position,
                key_type: params.key_type,
                json: false,
                reverse: params.reverse,
            };
            if (params.index) {
                const fieldToIndexMapping = this.getFieldToIndex();
                if (!fieldToIndexMapping[params.index]) {
                    throw new Error(`Field ${params.index} is not listed in the ABI under key_names/key_types. Try using 'index_position' instead.`);
                }
                tableRowsParams.index_position = fieldToIndexMapping[params.index].index_position;
            }
            const { rows } = yield this.client.v1.chain.get_table_rows(tableRowsParams);
            if (rows.length === 0) {
                return undefined;
            }
            let [row] = rows;
            if (!this.rowType) {
                row = antelope.Serializer.decode({
                    data: row,
                    abi: this.abi,
                    type: this.tableABI.type,
                });
            }
            if (params.json) {
                row = antelope.Serializer.objectify(row);
            }
            return row;
        });
    }
    first(maxRows, params = {}) {
        return this.query(Object.assign(Object.assign({}, params), { maxRows }));
    }
    all(params = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.query(params).all();
        });
    }
    getFieldToIndex() {
        if (this.fieldToIndex) {
            return this.fieldToIndex;
        }
        const fieldToIndex = {};
        for (let i = 0; i < this.tableABI.key_names.length; i++) {
            fieldToIndex[this.tableABI.key_names[i]] = {
                type: this.tableABI.key_types[i],
                index_position: indexPositionInWords(i),
            };
        }
        return fieldToIndex;
    }
    scopes(params = {}) {
        const tableRowsParams = {
            code: this.account,
            table: this.name,
            lower_bound: wrapIndexValue(params.from),
            upper_bound: wrapIndexValue(params.to),
            limit: params.rowsPerAPIRequest || this.defaultRowLimit,
            reverse: params.reverse,
        };
        return new TableScopeCursor({
            abi: this.abi,
            client: this.client,
            maxRows: params.maxRows,
            params: tableRowsParams,
        });
    }
}

class Contract {
    constructor(args) {
        if (!args.abi) {
            throw new Error('Contract requires an ABI');
        }
        this.abi = antelope.ABI.from(args.abi);
        if (!args.account) {
            throw new Error('Contract requires an account name');
        }
        this.account = antelope.Name.from(args.account);
        if (!args.client) {
            throw new Error('Contract requires an APIClient');
        }
        this.client = args.client;
    }
    get tableNames() {
        return this.abi.tables.map((table) => String(table.name));
    }
    hasTable(name) {
        return this.tableNames.includes(String(name));
    }
    table(name, scope, rowType) {
        if (!this.hasTable(name)) {
            throw new Error(`Contract (${this.account}) does not have a table named (${name})`);
        }
        return Table.from({
            abi: this.abi,
            account: this.account,
            client: this.client,
            defaultScope: scope,
            name,
            rowType,
        });
    }
    get actionNames() {
        return this.abi.actions.map((action) => String(action.name));
    }
    hasAction(name) {
        return this.actionNames.includes(String(name));
    }
    action(name, data, options) {
        if (!this.hasAction(name)) {
            throw new Error(`Contract (${this.account}) does not have an action named (${name})`);
        }
        let authorization = [signingRequest.PlaceholderAuth];
        if (options && options.authorization) {
            authorization = options.authorization.map((auth) => antelope.PermissionLevel.from(auth));
        }
        return antelope.Action.from({
            account: this.account,
            name,
            authorization,
            data,
        }, this.abi);
    }
    readonly(name, data) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!data) {
                data = {};
            }
            const action = this.action(name, data);
            action.authorization = [];
            const transaction = antelope.Transaction.from({
                ref_block_num: 0,
                ref_block_prefix: 0,
                expiration: 0,
                actions: [action],
            });
            const response = yield this.client.v1.chain.send_read_only_transaction(transaction);
            const hexData = response.processed.action_traces[0].return_value_hex_data;
            const returnType = this.abi.action_results.find((a) => antelope.Name.from(a.name).equals(name));
            if (!returnType) {
                throw new Error(`Return type for ${name} not defined in the ABI.`);
            }
            return antelope.Serializer.decode({
                data: hexData,
                type: returnType.result_type,
                abi: this.abi,
            });
        });
    }
    actions(actions, options) {
        return actions.map((action) => this.action(action.name, action.data, {
            authorization: action.authorization || (options === null || options === void 0 ? void 0 : options.authorization),
        }));
    }
    ricardian(name) {
        if (!this.hasAction(name)) {
            throw new Error(`Contract (${this.account}) does not have an action named (${name})`);
        }
        const action = this.abi.actions.find((action) => antelope.Name.from(action.name).equals(name));
        if (!action || !action.ricardian_contract) {
            throw new Error(`Contract (${this.account}) action named (${name}) does not have a defined ricardian contract`);
        }
        return action.ricardian_contract;
    }
}

const defaultContractKitOptions = {};
class ContractKit {
    constructor(args, options = defaultContractKitOptions) {
        if (args.client) {
            this.client = args.client;
        }
        else {
            throw new Error('A `client` must be passed when initializing the ContractKit.');
        }
        if (options.abiCache) {
            this.abiCache = options.abiCache;
        }
        else {
            this.abiCache = new abicache.ABICache(this.client);
        }
        if (options.abis) {
            options.abis.forEach(({ name, abi }) => this.abiCache.setAbi(antelope.Name.from(name), antelope.ABI.from(abi)));
        }
    }
    load(contract) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const account = antelope.Name.from(contract);
            const abiDef = yield this.abiCache.getAbi(account);
            return new Contract({
                abi: antelope.ABI.from(abiDef),
                account,
                client: this.client,
            });
        });
    }
}

exports.Contract = Contract;
exports.ContractKit = ContractKit;
exports.Table = Table;
exports.TableRowCursor = TableRowCursor;
exports.TableScopeCursor = TableScopeCursor;
exports.abiToBlob = abiToBlob;
exports.blobStringToAbi = blobStringToAbi;
exports.capitalize = capitalize;
exports["default"] = ContractKit;
exports.indexPositionInWords = indexPositionInWords;
exports.pascalCase = pascalCase;
exports.singularize = singularize;
exports.wrapIndexValue = wrapIndexValue;
//# sourceMappingURL=contract.js.map
